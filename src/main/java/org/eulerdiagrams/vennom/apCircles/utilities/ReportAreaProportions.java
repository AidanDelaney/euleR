package org.eulerdiagrams.vennom.apCircles.utilities;import java.io.*;import java.util.ArrayList;import java.util.HashMap;import java.awt.*;import java.awt.event.*;import java.awt.geom.*;import org.eulerdiagrams.vennom.apCircles.ConcreteContour;import org.eulerdiagrams.vennom.apCircles.RegularPolygon;import org.eulerdiagrams.vennom.apCircles.Util;import org.eulerdiagrams.vennom.apCircles.display.APCircleDisplay;import org.eulerdiagrams.vennom.graph.*;import org.eulerdiagrams.vennom.graph.utilities.GraphUtility;/** * Just for quick testing of methods. */public class ReportAreaProportions extends GraphUtility {	public static int polygonResolution = 10000;	private float scalingFactor;/** Trivial constructor. */	public ReportAreaProportions() {		super(KeyEvent.VK_A,"Area Calculation Report",KeyEvent.VK_A);	}	public void apply() {				System.out.println("Area Calculation Report");		report(getGraph());	}		public void report(Graph g) {		ArrayList<ConcreteContour> circleConcreteContours = convertCirclesToCCs(g);				HashMap<String, Area> zoneAreaMap = ConcreteContour.generateZoneAreas(circleConcreteContours);		for (String zone : zoneAreaMap.keySet()) {			Area area = zoneAreaMap.get(zone);			ArrayList<Polygon> polygons = ConcreteContour.polygonsFromArea(area);			if (zone.equals("")) {				// outer zone				continue;			}			// remove polygons that surround holes in the zone			// we only want polygons where the fill is the zone			// eg. diagram "0 a b ab" where a and b go through each other			// has two polys filled with the zone for both a and b			// the diagram "0 a b" drawn normally has three			// polys for 0 (including border), only one of which			// is filled with 0.			//			// What about holes in holes? Does this happen with			// simple polygons? I don't think so.			ArrayList<Polygon> polysCopy = new ArrayList<Polygon>(polygons);			for (Polygon polygon : polysCopy) {				Point2D insidePoint = ConcreteContour.findPointInsidePolygon(polygon);				if (insidePoint != null && !area.contains(insidePoint)) {					polygons.remove(polygon);				}			}			System.out.print(zone+" ");			for(Polygon p : polygons) {graphPanel.polygons.add(p);				float scaledPolygonArea = Util.computePolygonAreaFloat(p);				float polygonArea= scaledPolygonArea/(scalingFactor*scalingFactor);				System.out.print(polygonArea+" ");			}			System.out.println();					}			}	private ArrayList<ConcreteContour> convertCirclesToCCs(Graph g) {		ArrayList<ConcreteContour> circleContours = new ArrayList<ConcreteContour>();		graphPanel.polygons = new ArrayList<Polygon>();		// scale polygons for best resolution		float biggestRadius = -1;		int i = 0;		for(Node n : g.getNodes()) {			double radius = Double.parseDouble(n.getLabel());			if(radius > biggestRadius) {				biggestRadius = (float)radius;			}			i++;		}		scalingFactor = 1.0E4f/biggestRadius; // value found by experimentation//scalingFactor = 1;//System.out.println("Approximation error ");		for(Node n : g.getNodes()) {			int scaledX = Util.convertToInteger(n.getX()*scalingFactor);			int scaledY = Util.convertToInteger(n.getY()*scalingFactor);						double radius = Double.parseDouble(n.getLabel());						Polygon p = RegularPolygon.generateRegularPolygon(scaledX, scaledY, radius*scalingFactor, polygonResolution);						ConcreteContour cc = new ConcreteContour(n.getContour(), p);			circleContours.add(cc);			// graphPanel.polygons.add(p);//report approximation error						double actualArea = (float)(Math.PI*radius*radius);//System.out.println("scaledActualArea "+(actualArea*scalingFactor*scalingFactor));			float scaledPolygonArea = Util.computePolygonAreaFloat(p);//System.out.println(n.getContour()+" scaledPolygonArea "+scaledPolygonArea);			float polygonArea= scaledPolygonArea/(scalingFactor*scalingFactor);			double percentError = 100*(polygonArea-actualArea)/actualArea;			if(Math.abs(percentError) > 0.1) {				System.out.println(n.getContour()+" has circle area error > 0.1% is: "+percentError+"% actual area: "+actualArea+" polygon Area: "+polygonArea);			}		}				return circleContours;	}	}