package org.eulerdiagrams.vennom.apCircles.utilities;import java.io.*;import java.util.*;import java.awt.Point;import java.awt.Polygon;import java.awt.event.*;import java.awt.geom.Area;import java.awt.geom.Ellipse2D;import java.awt.geom.Point2D;import org.eulerdiagrams.vennom.apCircles.*;import org.eulerdiagrams.vennom.apCircles.drawers.*;import org.eulerdiagrams.vennom.graph.*;import org.eulerdiagrams.vennom.graph.utilities.GraphUtility;/** * Just for quick testing of methods. */public class TestRandomPierced extends GraphUtility implements Serializable {	public double zoneChance = 0.3;	public int minNumberOfCircles = 3;	public int maxNumberOfCircles = 5;	public int zoneAreaMin = 100;	public int zoneAreaMax = 10000;		public int numberOfTests = 100;		AreaSpecification as = null;	static private int polygonResolution = 10000;	static ArrayList<String> missingZones = null;	static ArrayList<String> additionalZones = null;		static HashMap<String,Double> errorMap = null;	private static final long serialVersionUID = 1L;/** Trivial constructor. */	public TestRandomPierced() {		super(KeyEvent.VK_1,"Test Random Pierced",KeyEvent.VK_1);	}	public void apply() {		as = null;		Graph g = null;		Random random = new Random(100);		int i = 0;		for(int diagramNo = 1; diagramNo <= numberOfTests; diagramNo++) {			int numberOfCircles = random.nextInt(1+maxNumberOfCircles-minNumberOfCircles);			numberOfCircles += minNumberOfCircles;System.out.println("diagram "+diagramNo+" numberOfCircles "+numberOfCircles+" i "+i);			while(g == null) {				i++;				as = createRandomPiercedSpecification(numberOfCircles, i);				if(as.getAbstractDiagram().findIntersectionGroups().size() > 1) { // no disconnected diagrams					 g = null;					 continue;				}				if(as.getAbstractDiagram().findConcurrentContours().size() > 0) { // no concurrent contours					 g = null;					 continue;				}				g = as.generatePiercedAugmentedIntersectionGraph();				if(g != null && g.getEdges().size() == 0) { // no trivial diagrams					g = null;					 continue;				}			}						String asString = as.toString();			asString = asString.replace('\n', ':');			long startTime = -1;			startTime = System.currentTimeMillis();			runPiercedTest(as);			double piercedTime = (System.currentTimeMillis()-startTime)/1000.0;			System.out.println("pierced\t"+asString+"\t"+report(as,getGraphPanel().getGraph())+"\t"+piercedTime);			startTime = System.currentTimeMillis();			runGeneralTest(as);			double generalTime = (System.currentTimeMillis()-startTime)/1000.0;			System.out.println("general\t"+asString+"\t"+report(as,getGraphPanel().getGraph())+"\t"+generalTime);			g = null;		}	}			public static String report(AreaSpecification ad, Graph g) {		findErrors(ad,g);		String ret = "";		ret += "\t"+(missingZones.size()+additionalZones.size());//System.out.println("missing "+missingZones);//System.out.println("additional "+additionalZones);//System.out.println("errorTotal "+errorTotal);		double errorTotal = 0.0;		for(String zone : errorMap.keySet()) {			errorTotal += errorMap.get(zone);		}				ret += "\t"+errorTotal;				return ret;	}	protected void runPiercedTest(AreaSpecification as) {		Graph g = as.generatePiercedAugmentedIntersectionGraph();		getGraphPanel().setGraph(g);		PiercedAPForceModel fm = new PiercedAPForceModel();		fm.setGraphPanel(getGraphPanel());		fm.setRandomize(false);		fm.setAnimateFlag(false);		fm.layout();	}	protected void runGeneralTest(AreaSpecification as) {		Graph g = as.generateGeneralAugmentedIntersectionGraph();		getGraphPanel().setGraph(g);		GeneralAPForceModel fm = new GeneralAPForceModel();		fm.setGraphPanel(getGraphPanel());		fm.setRandomize(false);		fm.setAnimateFlag(false);		fm.layout();	}			public AreaSpecification createRandomPiercedSpecification(int circleCount, long seed) {				AbstractDiagram ad = AbstractDiagram.randomDiagramFactory(circleCount,false,zoneChance,seed);		Random random = new Random(seed+1);		HashMap<String,Double> mapping = new HashMap<String,Double>();		for(String zone : ad.getZoneList()) {			double area = random.nextInt(1+zoneAreaMax-zoneAreaMin);			mapping.put(zone,area);		}		AreaSpecification as = new AreaSpecification(ad,mapping);				return as;	}		public static void findErrors(AreaSpecification as, Graph g) {		ArrayList<ConcreteContour> circleConcreteContours = AreaSpecification.convertCirclesToCCs(g,polygonResolution);		HashMap<String,Double> currentValuesMap = new HashMap<String,Double>();		HashMap<String, Area> zoneAreaMap = ConcreteContour.generateZoneAreas(circleConcreteContours);		for (String zone : zoneAreaMap.keySet()) {			Area area = zoneAreaMap.get(zone);			ArrayList<Polygon> polygons = ConcreteContour.polygonsFromArea(area);			if (zone.equals("")) {				// outer zone				continue;			}			// remove polygons that surround holes in the zone			// we only want polygons where the fill is the zone			// eg. diagram "0 a b ab" where a and b go through each other			// has two polys filled with the zone for both a and b			// the diagram "0 a b" drawn normally has three			// polys for 0 (including border), only one of which			// is filled with 0.			//			// What about holes in holes? Does this happen with			// simple polygons? I don't think so.			ArrayList<Polygon> polysCopy = new ArrayList<Polygon>(polygons);			for (Polygon polygon : polysCopy) {				Point2D insidePoint = ConcreteContour.findPointInsidePolygon(polygon);				if (insidePoint != null && !area.contains(insidePoint)) {					polygons.remove(polygon);				}			}			double totalPolygonArea = 0.0;			for(Polygon p : polygons) {//graphPanel.polygons.add(p);				double scaledPolygonArea = Util.computePolygonArea(p);				double polygonArea= scaledPolygonArea/(AreaSpecification.scalingFactor*AreaSpecification.scalingFactor);				totalPolygonArea += polygonArea;			}			currentValuesMap.put(zone,totalPolygonArea);		}				double currentTotal = 0.0;		for(String zone : currentValuesMap.keySet()) {			double value = currentValuesMap.get(zone);			currentTotal += value;		}		HashSet<String> allZones = new HashSet<String>(currentValuesMap.keySet());				allZones.addAll(as.getSpecification().keySet());		double requiredTotal = 0.0;		for(String zone : as.getSpecification().keySet()) {			double value = as.getSpecification().get(zone);			requiredTotal += value;		}				ArrayList<String> allZonesList = new ArrayList<String>(allZones);		boolean unique = AbstractDiagram.sortZoneList(allZonesList);		if(!unique) {			System.out.println("DUPLICATE ZONES");		}		//System.out.println("all"+ allZonesList);//System.out.println("current "+currentValuesMap.keySet());//System.out.println("required "+as.getAbstractDiagram().getZoneList());		errorMap = new HashMap<String, Double>();		for(String zone : allZonesList) {			if(zone.equals("")) {				continue;			}			Double actual = currentValuesMap.get(zone);			if(actual == null) {				actual = 0.0;			}			actual = actual/currentTotal;			Double required = as.getSpecification().get(zone);			if(required == null) {				required = 0.0;			}			required = required/requiredTotal;			double errorFraction = 1.0;			if(required != 0.0) {				errorFraction = Math.abs((required-actual)/required);			}			//System.out.println("|"+zone+"| actual "+actual+" required "+required+" error "+errorFraction);			errorMap.put(zone,errorFraction);		}//System.out.println(actualCheck +" "+requiredCheck+" both should be 1");						missingZones = new ArrayList<String>();		for(String zone : as.getAbstractDiagram().getZoneList()) {			if(zone == "") {				continue;			}			if(currentValuesMap.get(zone) == null) {				missingZones.add(zone);			}		}				additionalZones = new ArrayList<String>();		for(String zone : currentValuesMap.keySet()) {			if(zone == "") {				continue;			}			if(!as.getAbstractDiagram().getZoneList().contains(zone)) {				additionalZones.add(zone);			}		}					}		}